  本例程主要介绍WAV格式音乐文件的播放.

  因为wav格式就是直接记录的声音的PCM数据,是原始值没有经过压缩处理的.

  wav文件由若干个chunk组成:RIFF WAVE Chunk,Format Chunk,Fact Chunk(可选),Data Chunk.
音乐数据在Data Chunk中,前面RIFF WAVE Chunk,Format Chunk,Fact Chunk(可选)的大小均为偶数.
因此在本例中我们播放与音频DAC对应的固定参数的WAV音乐,不再读取文件头识别音乐的采样率和大小.
同时也不区分文件头和数据,直接把所有数据全部 "扔" DAC.
本例我们使用的wav文件参数为:  位速1411Kbps(44.1K),16bit,stereo. <大部转换软件默认即本参数>

  大多数系统中,从文件系统中读取数据的速度要比发送到设备中快很多.
但每建立一次读取数据的过程却耗时颇多.
因此大多数流处理中都使用双缓冲技术(也叫乒乓缓冲),本例也一样.
但本例使用RTT一个很有用的组件-内存池(mempool)来助我们实现.

  内存池在创建时向系统申请一大块内存，然后分成同样大小的多个小内存块，形成链表连接起来
(此链表也称为空闲链表).每次分配的时候，从空闲链表中取出头上一块，提供给申请者。
当申请不成功时,申请者即被挂起.我们正是利用此特性控制数据的读取进度.

运作流程:

finsh>>wav("/test.wav")

    1.打开文件.
|-> 2.从内存池申请一片空间.
|     如果不成功则挂起等待.        <---  如果此时有申请在等待,就会成功返回   <--------|
|   3.读取文件中的数据到缓存中.                                                       |
|   4.将缓存中的数据发送到DAC.            |                                           |
|     如果设备已经在发送.                 |--当设备每发送完一片缓冲区,就释放本内存池--|
|     则把设备添加到设备驱动的待发送队列. |
|-- 5.判断文件是否读取完成,否则回到步骤2


















